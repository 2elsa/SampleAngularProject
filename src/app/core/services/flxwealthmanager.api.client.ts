/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IFlxWealthManagerApiClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginModel | undefined): Observable<LoginToken>;
    /**
     * @param body (optional) 
     * @return Success
     */
    createNewUser(body?: User | undefined): Observable<User>;
    /**
     * @param body (optional) 
     * @return Success
     */
    requestPasswordReset(body?: EmailModel | undefined): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    passwordReset(body?: PasswordModel | undefined): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    emailConfirmation(body?: EmailModel | undefined): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveClient(body?: Client | undefined): Observable<Client>;
    /**
     * @param body (optional) 
     * @return Success
     */
    clients(body?: Client | undefined): Observable<Client>;
    /**
     * @return Success
     */
    updateTagline(id: number, tagline: string | null): Observable<Client>;
    /**
     * @return Success
     */
    getClient(id: number): Observable<Client>;
    /**
     * @return Success
     */
    getAllClients(): Observable<Client[]>;
    /**
     * @return Success
     */
    deleteClient(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveCountry(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCountry(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getCountry(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllCountries(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteCountry(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveState(body?: CountryState | undefined): Observable<CountryState>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateState(body?: CountryState | undefined): Observable<CountryState>;
    /**
     * @return Success
     */
    getAllStates(countryId: number): Observable<CountryState[]>;
    /**
     * @return Success
     */
    deleteState(id: number): Observable<boolean>;
    /**
     * @return Success
     */
    confirmEmailTemplatePath(): Observable<string>;
    /**
     * @return Success
     */
    confirmEmailTemplate(): Observable<string>;
    /**
     * @return Success
     */
    passwordResetTemplatePath(): Observable<string>;
    /**
     * @return Success
     */
    passwordResetTemplate(): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveClientFocusOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateClientFocusOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getClientFocusOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllClientFocusOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteClientFocusOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveContactFrequencyOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactFrequencyOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getContactFrequencyOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllContactFrequencyOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteContactFrequencyOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveContactTimeOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactTimeOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getContactTimeOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllContactTimeOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteContactTimeOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveDesiredSolutionOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateDesiredSolutionOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getDesiredSolutionOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllDesiredSolutionOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteDesiredSolutionOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvestmentImplementationOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvestmentImplementationOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getInvestmentImplementationOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllInvestmentImplementationOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteInvestmentImplementationOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    savePreferredEngagementOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updatePreferredEngagementOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getPreferredEngagementOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllPreferredEngagementOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deletePreferredEngagementOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllocationOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllocationOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllocationOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllAllocationOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteAllocationOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveAlternativeOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateAlternativeOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAlternativeOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllAlternativeOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteAlternativeOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveCommodityOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommodityOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getCommodityOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllCommodityOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteCommodityOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveEquityOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateEquityOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getEquityOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllEquityOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteEquityOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveInternationalEquityOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateInternationalEquityOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getInternationalEquityOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllInternationalEquityOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteInternationalEquityOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveMoneyMarketOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateMoneyMarketOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getMoneyMarketOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllMoneyMarketOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteMoneyMarketOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveMunicipalBondOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateMunicipalBondOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getMunicipalBondOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllMunicipalBondOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteMunicipalBondOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveProductOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getProductOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllProductOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteProductOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveSectorEquityOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateSectorEquityOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getSectorEquityOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllSectorEquityOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteSectorEquityOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveTaxableBondOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateTaxableBondOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getTaxableBondOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllTaxableBondOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteTaxableBondOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    savePermissionLevel(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updatePermissionLevel(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getPermissionLevel(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllPermissionLevels(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deletePermissionLevel(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserBiography(body?: UserBiography | undefined): Observable<UserBiography>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserBiography(body?: UserBiography | undefined): Observable<UserBiography>;
    /**
     * @return Success
     */
    getUserBiography(id: number): Observable<UserBiography>;
    /**
     * @return Success
     */
    getAllBiographies(): Observable<UserBiography[]>;
    /**
     * @return Success
     */
    deleteUserBiography(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserEducation(body?: UserEducation | undefined): Observable<UserEducation>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserEducation(body?: UserEducation | undefined): Observable<UserEducation>;
    /**
     * @return Success
     */
    getUserEducation(id: number): Observable<UserEducation>;
    /**
     * @return Success
     */
    getAllEducations(): Observable<UserEducation[]>;
    /**
     * @return Success
     */
    getAllUserEducations(userId: number): Observable<UserEducation[]>;
    /**
     * @return Success
     */
    deleteUserEducation(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserHonorAward(body?: UserHonorAndAward | undefined): Observable<UserHonorAndAward>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserHonorAward(body?: UserHonorAndAward | undefined): Observable<UserHonorAndAward>;
    /**
     * @return Success
     */
    getUserHonorAward(id: number): Observable<UserHonorAndAward>;
    /**
     * @return Success
     */
    getAllHonorsAndAwards(): Observable<UserHonorAndAward[]>;
    /**
     * @return Success
     */
    getAllUserHonorsAndAwards(userId: number): Observable<UserHonorAndAward[]>;
    /**
     * @return Success
     */
    deleteUserHonorAward(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserJobHistory(body?: UserJobHistory | undefined): Observable<UserJobHistory>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserJobHistory(body?: UserJobHistory | undefined): Observable<UserJobHistory>;
    /**
     * @return Success
     */
    getUserJobHistory(id: number): Observable<UserJobHistory>;
    /**
     * @return Success
     */
    getAllJobHistories(): Observable<UserJobHistory[]>;
    /**
     * @param userId (optional) 
     * @return Success
     */
    getAllUserJobHistories(userId?: number | undefined): Observable<UserJobHistory[]>;
    /**
     * @return Success
     */
    deleteUserJobHistory(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserLinkedIn(body?: UserLinkedIn | undefined): Observable<UserLinkedIn>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserLinkedIn(body?: UserLinkedIn | undefined): Observable<UserLinkedIn>;
    /**
     * @return Success
     */
    getUserLinkedIn(id: number): Observable<UserLinkedIn>;
    /**
     * @return Success
     */
    getAllLinkedIn(): Observable<UserLinkedIn[]>;
    /**
     * @return Success
     */
    deleteUserLinkedIn(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserProfessionalAssociation(body?: UserProfessionalAssociation | undefined): Observable<UserProfessionalAssociation>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserProfessionalAssociation(body?: UserProfessionalAssociation | undefined): Observable<UserProfessionalAssociation>;
    /**
     * @return Success
     */
    getUserProfessionalAssociation(id: number): Observable<UserProfessionalAssociation>;
    /**
     * @return Success
     */
    getAllProfessionalAssociations(): Observable<UserProfessionalAssociation[]>;
    /**
     * @return Success
     */
    getAllUserProfessionalAssociations(userId: number): Observable<UserProfessionalAssociation[]>;
    /**
     * @return Success
     */
    deleteUserProfessionalAssociation(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveRegistrationOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateRegistrationOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getRegistrationOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllRegistrationOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteRegistrationOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveCertificateOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCertificateOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getCertificateOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllCertificateOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteCertificateOption(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveIndustryExperienceOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateIndustryExperienceOption(body?: NamedModel | undefined): Observable<NamedModel>;
    /**
     * @return Success
     */
    getIndustryExperienceOption(id: number): Observable<NamedModel>;
    /**
     * @return Success
     */
    getAllIndustryExperienceOptions(): Observable<NamedModel[]>;
    /**
     * @return Success
     */
    deleteIndustryExperienceOption(id: number): Observable<boolean>;
    /**
     * @return Success
     */
    getTopStories(): Observable<ExternalResponse>;
    /**
     * @return Success
     */
    getServerEnvironment(): Observable<string>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body?: User | undefined): Observable<User>;
    /**
     * @return Success
     */
    getUser(id: number): Observable<User>;
    /**
     * @return Success
     */
    getUserDetails(id: number): Observable<User>;
    /**
     * @return Success
     */
    getAllUsers(): Observable<User[]>;
    /**
     * @return Success
     */
    getUsersByClientId(clientId: number): Observable<User[]>;
    /**
     * @return Success
     */
    deleteUser(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveCrd(body?: UserCrd | undefined): Observable<UserCrd>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCrd(body?: UserCrd | undefined): Observable<UserCrd>;
    /**
     * @return Success
     */
    getCrd(id: number): Observable<UserCrd>;
    /**
     * @return Success
     */
    getUserCrd(userId: number): Observable<UserCrd>;
    /**
     * @return Success
     */
    getAllCrds(): Observable<UserCrd[]>;
    /**
     * @return Success
     */
    deleteCrd(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserClientFocus(body?: UserClientFocus | undefined): Observable<UserClientFocus>;
    /**
     * @return Success
     */
    getUserClientFocus(id: number): Observable<UserClientFocus>;
    /**
     * @return Success
     */
    getAllUserClientFocus(userId: number): Observable<UserClientFocus[]>;
    /**
     * @return Success
     */
    deleteUserClientFocus(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserContactFrequency(body?: UserContactFrequency | undefined): Observable<UserContactFrequency>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserContactFrequency(body?: UserContactFrequency | undefined): Observable<UserContactFrequency>;
    /**
     * @return Success
     */
    getUserContactFrequency(id: number): Observable<UserContactFrequency>;
    /**
     * @return Success
     */
    getAllUserContactFrequency(userId: number): Observable<UserContactFrequency[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserContactTime(body?: UserContactTime | undefined): Observable<UserContactTime>;
    /**
     * @return Success
     */
    getUserContactTime(id: number): Observable<UserContactTime>;
    /**
     * @return Success
     */
    getAllUserContactTime(userId: number): Observable<UserContactTime[]>;
    /**
     * @return Success
     */
    deleteUserContactTime(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserDesiredSolution(body?: UserDesiredSolutionService | undefined): Observable<UserDesiredSolutionService>;
    /**
     * @return Success
     */
    getUserDesiredSolution(id: number): Observable<UserDesiredSolutionService>;
    /**
     * @return Success
     */
    getAllUserDesiredSolution(userId: number): Observable<UserDesiredSolutionService[]>;
    /**
     * @return Success
     */
    deleteUserDesiredSolution(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserInvestmentImplementation(body?: UserInvestmentImplementation | undefined): Observable<UserInvestmentImplementation>;
    /**
     * @return Success
     */
    getUserInvestmentImplementation(id: number): Observable<UserInvestmentImplementation>;
    /**
     * @return Success
     */
    getAllUserInvestmentImplementation(userId: number): Observable<UserInvestmentImplementation[]>;
    /**
     * @return Success
     */
    deleteUserInvestmentImplementation(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserPreferredEngagement(body?: UserPreferredEngagement | undefined): Observable<UserPreferredEngagement>;
    /**
     * @return Success
     */
    getUserPreferredEngagement(id: number): Observable<UserPreferredEngagement>;
    /**
     * @return Success
     */
    getAllUserPreferredEngagement(userId: number): Observable<UserPreferredEngagement[]>;
    /**
     * @return Success
     */
    deleteUserPreferredEngagement(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserAllocation(body?: UserAllocation | undefined): Observable<UserAllocation>;
    /**
     * @return Success
     */
    getUserAllocation(id: number): Observable<UserAllocation>;
    /**
     * @return Success
     */
    getAllUserAllocations(userId: number): Observable<UserAllocation[]>;
    /**
     * @return Success
     */
    deleteUserAllocation(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserAlternative(body?: UserAlternative | undefined): Observable<UserAlternative>;
    /**
     * @return Success
     */
    getUserAlternative(id: number): Observable<UserAlternative>;
    /**
     * @return Success
     */
    getUserAllAlternatives(userId: number): Observable<UserAlternative[]>;
    /**
     * @return Success
     */
    deleteUserAlternative(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserCommodity(body?: UserCommodity | undefined): Observable<UserCommodity>;
    /**
     * @return Success
     */
    getUserCommodity(id: number): Observable<UserCommodity>;
    /**
     * @return Success
     */
    getAllCommodities(userId: number): Observable<UserCommodity[]>;
    /**
     * @return Success
     */
    deleteUserCommodity(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserEquity(body?: UserEquity | undefined): Observable<UserEquity>;
    /**
     * @return Success
     */
    getUserEquity(id: number): Observable<UserEquity>;
    /**
     * @return Success
     */
    getAllUserEquities(userId: number): Observable<UserEquity[]>;
    /**
     * @return Success
     */
    deleteUserEquity(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserInternationalEquity(body?: UserInternationalEquity | undefined): Observable<UserInternationalEquity>;
    /**
     * @return Success
     */
    getUserInternationalEquity(id: number): Observable<UserInternationalEquity>;
    /**
     * @return Success
     */
    getAllUserInternationalEquities(userId: number): Observable<UserInternationalEquity[]>;
    /**
     * @return Success
     */
    deleteUserInternationalEquity(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserMoneyMarket(body?: UserMoneyMarket | undefined): Observable<UserMoneyMarket>;
    /**
     * @return Success
     */
    getUserMoneyMarket(id: number): Observable<UserMoneyMarket>;
    /**
     * @return Success
     */
    getAllUserMoneyMarkets(userId: number): Observable<UserMoneyMarket[]>;
    /**
     * @return Success
     */
    deleteUserMoneyMarket(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserMunicipalBond(body?: UserMunicipalBond | undefined): Observable<UserMunicipalBond>;
    /**
     * @return Success
     */
    getUserMunicipalBond(id: number): Observable<UserMunicipalBond>;
    /**
     * @return Success
     */
    getAllUserMunicipalBonds(userId: number): Observable<UserMunicipalBond[]>;
    /**
     * @return Success
     */
    deleteUserMunicipalBond(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserProduct(body?: UserProduct | undefined): Observable<UserProduct>;
    /**
     * @return Success
     */
    getUserProduct(id: number): Observable<UserProduct>;
    /**
     * @return Success
     */
    getAllUserProducts(userId: number): Observable<UserProduct[]>;
    /**
     * @return Success
     */
    deleteUserProduct(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserSectorEquity(body?: UserSectorEquity | undefined): Observable<UserSectorEquity>;
    /**
     * @return Success
     */
    getUserSectorEquity(id: number): Observable<UserSectorEquity>;
    /**
     * @return Success
     */
    getAllUserSectorEquities(userId: number): Observable<UserSectorEquity[]>;
    /**
     * @return Success
     */
    deleteUserSectorEquity(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserTaxableBond(body?: UserTaxableBond | undefined): Observable<UserTaxableBond>;
    /**
     * @return Success
     */
    getUserTaxableBond(id: number): Observable<UserTaxableBond>;
    /**
     * @return Success
     */
    getAllUserTaxableBonds(userId: number): Observable<UserTaxableBond[]>;
    /**
     * @return Success
     */
    deleteUserTaxableBond(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveProfilePicture(body?: UserProfilePicture | undefined): Observable<UserProfilePicture>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body?: UserProfilePicture | undefined): Observable<UserProfilePicture>;
    /**
     * @return Success
     */
    getProfilePicture(userId: number): Observable<UserProfilePicture>;
    /**
     * @return Success
     */
    deleteProfilePicture(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserRegistration(body?: UserRegistration | undefined): Observable<UserRegistration>;
    /**
     * @return Success
     */
    getUserRegistration(id: number): Observable<UserRegistration>;
    /**
     * @return Success
     */
    getAllUserRegistration(userId: number): Observable<UserRegistration[]>;
    /**
     * @return Success
     */
    deleteUserRegistration(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserCertification(body?: UserCertification | undefined): Observable<UserCertification>;
    /**
     * @return Success
     */
    getUserCertification(id: number): Observable<UserCertification>;
    /**
     * @return Success
     */
    getAllUserCertification(userId: number): Observable<UserCertification[]>;
    /**
     * @return Success
     */
    deleteUserCertification(id: number): Observable<boolean>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserIndustryExperience(body?: UserIndustryExperience | undefined): Observable<UserIndustryExperience>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserIndustryExperience2(body?: UserIndustryExperience | undefined): Observable<UserIndustryExperience>;
    /**
     * @return Success
     */
    getUserIndustryExperience(id: number): Observable<UserIndustryExperience>;
    /**
     * @return Success
     */
    getAllUserIndustryExperience(userId: number): Observable<UserIndustryExperience[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    saveReviewer(body?: UserTeamReviewer | undefined): Observable<UserTeamReviewer>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateReviewer(body?: UserTeamReviewer | undefined): Observable<UserTeamReviewer>;
    /**
     * @return Success
     */
    getReviewer(id: number): Observable<UserTeamReviewer>;
    /**
     * @return Success
     */
    getUserReviewer(userId: number): Observable<UserTeamReviewer>;
    /**
     * @return Success
     */
    getAllReviewers(): Observable<UserTeamReviewer[]>;
    /**
     * @return Success
     */
    deleteReviewer(id: number): Observable<boolean>;
}

@Injectable()
export class FlxWealthManagerApiClient implements IFlxWealthManagerApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginModel | undefined): Observable<LoginToken> {
        let url_ = this.baseUrl + "/api/Accounts/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<LoginToken>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginToken>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginToken> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginToken.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginToken>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createNewUser(body?: User | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/Accounts/create-new-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNewUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNewUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processCreateNewUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestPasswordReset(body?: EmailModel | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Accounts/request-password-reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestPasswordReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestPasswordReset(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRequestPasswordReset(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    passwordReset(body?: PasswordModel | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Accounts/password-reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordReset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordReset(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPasswordReset(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    emailConfirmation(body?: EmailModel | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Accounts/email-confirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmailConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmailConfirmation(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processEmailConfirmation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveClient(body?: Client | undefined): Observable<Client> {
        let url_ = this.baseUrl + "/api/Clients/save-client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveClient(<any>response_);
                } catch (e) {
                    return <Observable<Client>><any>_observableThrow(e);
                }
            } else
                return <Observable<Client>><any>_observableThrow(response_);
        }));
    }

    protected processSaveClient(response: HttpResponseBase): Observable<Client> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Client.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Client>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clients(body?: Client | undefined): Observable<Client> {
        let url_ = this.baseUrl + "/api/Clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClients(<any>response_);
                } catch (e) {
                    return <Observable<Client>><any>_observableThrow(e);
                }
            } else
                return <Observable<Client>><any>_observableThrow(response_);
        }));
    }

    protected processClients(response: HttpResponseBase): Observable<Client> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Client.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Client>(<any>null);
    }

    /**
     * @return Success
     */
    updateTagline(id: number, tagline: string | null): Observable<Client> {
        let url_ = this.baseUrl + "/api/Clients/update-tagline/{id}/{tagline}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (tagline === undefined || tagline === null)
            throw new Error("The parameter 'tagline' must be defined.");
        url_ = url_.replace("{tagline}", encodeURIComponent("" + tagline));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTagline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTagline(<any>response_);
                } catch (e) {
                    return <Observable<Client>><any>_observableThrow(e);
                }
            } else
                return <Observable<Client>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTagline(response: HttpResponseBase): Observable<Client> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Client.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Client>(<any>null);
    }

    /**
     * @return Success
     */
    getClient(id: number): Observable<Client> {
        let url_ = this.baseUrl + "/api/Clients/get-client/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClient(<any>response_);
                } catch (e) {
                    return <Observable<Client>><any>_observableThrow(e);
                }
            } else
                return <Observable<Client>><any>_observableThrow(response_);
        }));
    }

    protected processGetClient(response: HttpResponseBase): Observable<Client> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Client.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Client>(<any>null);
    }

    /**
     * @return Success
     */
    getAllClients(): Observable<Client[]> {
        let url_ = this.baseUrl + "/api/Clients/get-all-clients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClients(<any>response_);
                } catch (e) {
                    return <Observable<Client[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Client[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllClients(response: HttpResponseBase): Observable<Client[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Client.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Client[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteClient(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Clients/delete-client/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClient(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteClient(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCountry(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/Countrys/save-country";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCountry(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveCountry(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCountry(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/Countrys/update-country";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCountry(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCountry(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getCountry(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/Countrys/get-country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountry(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountry(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCountries(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/Countrys/get-all-countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountries(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCountries(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCountry(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Countrys/delete-country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCountry(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCountry(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveState(body?: CountryState | undefined): Observable<CountryState> {
        let url_ = this.baseUrl + "/api/Countrys/save-state";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveState(<any>response_);
                } catch (e) {
                    return <Observable<CountryState>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryState>><any>_observableThrow(response_);
        }));
    }

    protected processSaveState(response: HttpResponseBase): Observable<CountryState> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryState.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryState>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateState(body?: CountryState | undefined): Observable<CountryState> {
        let url_ = this.baseUrl + "/api/Countrys/update-state";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateState(<any>response_);
                } catch (e) {
                    return <Observable<CountryState>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryState>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateState(response: HttpResponseBase): Observable<CountryState> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryState.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryState>(<any>null);
    }

    /**
     * @return Success
     */
    getAllStates(countryId: number): Observable<CountryState[]> {
        let url_ = this.baseUrl + "/api/Countrys/get-all-states/{countryId}";
        if (countryId === undefined || countryId === null)
            throw new Error("The parameter 'countryId' must be defined.");
        url_ = url_.replace("{countryId}", encodeURIComponent("" + countryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStates(<any>response_);
                } catch (e) {
                    return <Observable<CountryState[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryState[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStates(response: HttpResponseBase): Observable<CountryState[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryState.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryState[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteState(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Countrys/delete-state/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteState(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteState(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteState(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    confirmEmailTemplatePath(): Observable<string> {
        let url_ = this.baseUrl + "/api/EmailTemplates/confirm-email-template-path";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmailTemplatePath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmailTemplatePath(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmailTemplatePath(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    confirmEmailTemplate(): Observable<string> {
        let url_ = this.baseUrl + "/api/EmailTemplates/confirm-email-template";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmailTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmailTemplate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmEmailTemplate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    passwordResetTemplatePath(): Observable<string> {
        let url_ = this.baseUrl + "/api/EmailTemplates/password-reset-template-path";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordResetTemplatePath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordResetTemplatePath(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPasswordResetTemplatePath(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    passwordResetTemplate(): Observable<string> {
        let url_ = this.baseUrl + "/api/EmailTemplates/password-reset-template";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPasswordResetTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPasswordResetTemplate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPasswordResetTemplate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveClientFocusOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/save-client-focus-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveClientFocusOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveClientFocusOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveClientFocusOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateClientFocusOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/update-client-focus-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClientFocusOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClientFocusOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateClientFocusOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getClientFocusOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-client-focus-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientFocusOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientFocusOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientFocusOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllClientFocusOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-all-client-focus-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClientFocusOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClientFocusOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllClientFocusOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteClientFocusOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/EngagementLookups/delete-client-focus-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClientFocusOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClientFocusOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteClientFocusOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveContactFrequencyOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/save-contact-frequency-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveContactFrequencyOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveContactFrequencyOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveContactFrequencyOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactFrequencyOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/update-contact-frequency-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactFrequencyOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactFrequencyOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactFrequencyOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getContactFrequencyOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-contact-frequency-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactFrequencyOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactFrequencyOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactFrequencyOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllContactFrequencyOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-all-contact-frequency-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactFrequencyOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactFrequencyOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContactFrequencyOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactFrequencyOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/EngagementLookups/delete-contact-frequency-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactFrequencyOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactFrequencyOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactFrequencyOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveContactTimeOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/save-contact-time-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveContactTimeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveContactTimeOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveContactTimeOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContactTimeOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/update-contact-time-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactTimeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactTimeOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateContactTimeOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getContactTimeOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-contact-time-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactTimeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactTimeOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactTimeOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllContactTimeOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-all-contact-time-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactTimeOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactTimeOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContactTimeOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteContactTimeOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/EngagementLookups/delete-contact-time-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactTimeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactTimeOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteContactTimeOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveDesiredSolutionOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/save-desired-solution-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDesiredSolutionOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDesiredSolutionOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveDesiredSolutionOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDesiredSolutionOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/update-desired-solution-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDesiredSolutionOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDesiredSolutionOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDesiredSolutionOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getDesiredSolutionOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-desired-solution-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDesiredSolutionOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDesiredSolutionOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetDesiredSolutionOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllDesiredSolutionOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-all-desired-solution-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDesiredSolutionOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDesiredSolutionOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDesiredSolutionOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteDesiredSolutionOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/EngagementLookups/delete-desired-solution-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDesiredSolutionOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDesiredSolutionOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDesiredSolutionOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInvestmentImplementationOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/save-investment-implementation-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvestmentImplementationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvestmentImplementationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveInvestmentImplementationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInvestmentImplementationOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/update-investment-implementation-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInvestmentImplementationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInvestmentImplementationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInvestmentImplementationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getInvestmentImplementationOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-investment-implementation-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvestmentImplementationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvestmentImplementationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvestmentImplementationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllInvestmentImplementationOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-all-investment-implementation-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInvestmentImplementationOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInvestmentImplementationOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllInvestmentImplementationOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteInvestmentImplementationOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/EngagementLookups/delete-investment-implementation-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInvestmentImplementationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInvestmentImplementationOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInvestmentImplementationOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePreferredEngagementOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/save-preferred-engagement-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePreferredEngagementOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePreferredEngagementOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSavePreferredEngagementOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePreferredEngagementOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/update-preferred-engagement-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePreferredEngagementOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePreferredEngagementOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePreferredEngagementOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getPreferredEngagementOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-preferred-engagement-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPreferredEngagementOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPreferredEngagementOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetPreferredEngagementOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPreferredEngagementOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/EngagementLookups/get-all-preferred-engagement-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPreferredEngagementOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPreferredEngagementOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPreferredEngagementOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deletePreferredEngagementOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/EngagementLookups/delete-preferred-engagement-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePreferredEngagementOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePreferredEngagementOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePreferredEngagementOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAllocationOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-allocation-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAllocationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAllocationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAllocationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllocationOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-allocation-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllocationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllocationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllocationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllocationOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-allocation-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllocationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllocationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllocationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllAllocationOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-allocation-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAllocationOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAllocationOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAllocationOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteAllocationOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-allocation-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllocationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllocationOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllocationOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveAlternativeOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-alternative-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAlternativeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAlternativeOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAlternativeOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAlternativeOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-alternative-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAlternativeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAlternativeOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAlternativeOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAlternativeOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-alternative-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAlternativeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAlternativeOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetAlternativeOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllAlternativeOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-alternative-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAlternativeOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAlternativeOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAlternativeOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteAlternativeOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-alternative-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAlternativeOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAlternativeOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAlternativeOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCommodityOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-commodity-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCommodityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCommodityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveCommodityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommodityOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-commodity-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommodityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommodityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCommodityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getCommodityOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-commodity-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCommodityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommodityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommodityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCommodityOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-commodity-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCommodityOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCommodityOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCommodityOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCommodityOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-commodity-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCommodityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCommodityOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCommodityOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveEquityOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-equity-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEquityOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-equity-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getEquityOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-equity-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEquityOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-equity-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEquityOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEquityOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEquityOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteEquityOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-equity-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEquityOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveInternationalEquityOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-international-equity-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInternationalEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInternationalEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveInternationalEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateInternationalEquityOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-international-equity-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInternationalEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInternationalEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateInternationalEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getInternationalEquityOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-international-equity-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInternationalEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInternationalEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetInternationalEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllInternationalEquityOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-international-equity-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInternationalEquityOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInternationalEquityOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllInternationalEquityOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteInternationalEquityOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-international-equity-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteInternationalEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteInternationalEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteInternationalEquityOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveMoneyMarketOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-money-market-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMoneyMarketOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMoneyMarketOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveMoneyMarketOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMoneyMarketOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-money-market-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMoneyMarketOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMoneyMarketOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMoneyMarketOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getMoneyMarketOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-money-market-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMoneyMarketOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMoneyMarketOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetMoneyMarketOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMoneyMarketOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-money-market-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMoneyMarketOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMoneyMarketOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMoneyMarketOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteMoneyMarketOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-money-market-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMoneyMarketOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMoneyMarketOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMoneyMarketOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveMunicipalBondOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-municipal-bond-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMunicipalBondOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMunicipalBondOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveMunicipalBondOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMunicipalBondOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-municipal-bond-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMunicipalBondOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMunicipalBondOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMunicipalBondOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getMunicipalBondOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-municipal-bond-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMunicipalBondOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMunicipalBondOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetMunicipalBondOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllMunicipalBondOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-municipal-bond-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMunicipalBondOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMunicipalBondOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMunicipalBondOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteMunicipalBondOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-municipal-bond-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMunicipalBondOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMunicipalBondOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMunicipalBondOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveProductOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-product-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveProductOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveProductOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveProductOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-product-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProductOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getProductOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-product-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllProductOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-product-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProductOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProductOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProductOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProductOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-product-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProductOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveSectorEquityOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-sector-equity-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSectorEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSectorEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveSectorEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSectorEquityOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-sector-equity-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSectorEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSectorEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSectorEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getSectorEquityOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-sector-equity-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSectorEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectorEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetSectorEquityOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllSectorEquityOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-sector-equity-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSectorEquityOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSectorEquityOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSectorEquityOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteSectorEquityOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-sector-equity-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSectorEquityOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSectorEquityOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSectorEquityOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveTaxableBondOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/save-taxable-bond-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTaxableBondOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTaxableBondOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveTaxableBondOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTaxableBondOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/update-taxable-bond-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTaxableBondOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTaxableBondOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTaxableBondOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getTaxableBondOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-taxable-bond-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxableBondOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxableBondOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxableBondOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllTaxableBondOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/get-all-taxable-bond-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTaxableBondOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaxableBondOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaxableBondOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteTaxableBondOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/InvestmentUtilizationLookups/delete-taxable-bond-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTaxableBondOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaxableBondOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTaxableBondOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePermissionLevel(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/PermissionLookups/save-permission-level";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePermissionLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePermissionLevel(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSavePermissionLevel(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePermissionLevel(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/PermissionLookups/update-permission-level";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermissionLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissionLevel(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissionLevel(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getPermissionLevel(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/PermissionLookups/get-permission-level/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionLevel(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissionLevel(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissionLevels(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/PermissionLookups/get-all-permission-levels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionLevels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionLevels(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissionLevels(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deletePermissionLevel(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/PermissionLookups/delete-permission-level/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePermissionLevel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePermissionLevel(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePermissionLevel(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserBiography(body?: UserBiography | undefined): Observable<UserBiography> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/save-user-biography";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserBiography(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserBiography(<any>response_);
                } catch (e) {
                    return <Observable<UserBiography>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBiography>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserBiography(response: HttpResponseBase): Observable<UserBiography> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBiography.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBiography>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserBiography(body?: UserBiography | undefined): Observable<UserBiography> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/update-user-biography";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserBiography(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserBiography(<any>response_);
                } catch (e) {
                    return <Observable<UserBiography>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBiography>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserBiography(response: HttpResponseBase): Observable<UserBiography> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBiography.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBiography>(<any>null);
    }

    /**
     * @return Success
     */
    getUserBiography(id: number): Observable<UserBiography> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-user-biography/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserBiography(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserBiography(<any>response_);
                } catch (e) {
                    return <Observable<UserBiography>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBiography>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserBiography(response: HttpResponseBase): Observable<UserBiography> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBiography.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBiography>(<any>null);
    }

    /**
     * @return Success
     */
    getAllBiographies(): Observable<UserBiography[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-biographies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBiographies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBiographies(<any>response_);
                } catch (e) {
                    return <Observable<UserBiography[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserBiography[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBiographies(response: HttpResponseBase): Observable<UserBiography[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserBiography.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserBiography[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserBiography(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/delete-user-biography/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserBiography(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserBiography(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserBiography(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserEducation(body?: UserEducation | undefined): Observable<UserEducation> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/save-user-education";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserEducation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserEducation(<any>response_);
                } catch (e) {
                    return <Observable<UserEducation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEducation>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserEducation(response: HttpResponseBase): Observable<UserEducation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEducation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEducation>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserEducation(body?: UserEducation | undefined): Observable<UserEducation> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/update-user-education";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserEducation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserEducation(<any>response_);
                } catch (e) {
                    return <Observable<UserEducation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEducation>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserEducation(response: HttpResponseBase): Observable<UserEducation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEducation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEducation>(<any>null);
    }

    /**
     * @return Success
     */
    getUserEducation(id: number): Observable<UserEducation> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-user-education/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserEducation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserEducation(<any>response_);
                } catch (e) {
                    return <Observable<UserEducation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEducation>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserEducation(response: HttpResponseBase): Observable<UserEducation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEducation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEducation>(<any>null);
    }

    /**
     * @return Success
     */
    getAllEducations(): Observable<UserEducation[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-educations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEducations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEducations(<any>response_);
                } catch (e) {
                    return <Observable<UserEducation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEducation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEducations(response: HttpResponseBase): Observable<UserEducation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEducation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEducation[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserEducations(userId: number): Observable<UserEducation[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-user-educations/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserEducations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserEducations(<any>response_);
                } catch (e) {
                    return <Observable<UserEducation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEducation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserEducations(response: HttpResponseBase): Observable<UserEducation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEducation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEducation[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserEducation(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/delete-user-education/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserEducation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserEducation(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserEducation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserHonorAward(body?: UserHonorAndAward | undefined): Observable<UserHonorAndAward> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/save-user-honor-award";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserHonorAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserHonorAward(<any>response_);
                } catch (e) {
                    return <Observable<UserHonorAndAward>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserHonorAndAward>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserHonorAward(response: HttpResponseBase): Observable<UserHonorAndAward> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserHonorAndAward.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserHonorAndAward>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserHonorAward(body?: UserHonorAndAward | undefined): Observable<UserHonorAndAward> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/update-user-honor-award";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserHonorAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserHonorAward(<any>response_);
                } catch (e) {
                    return <Observable<UserHonorAndAward>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserHonorAndAward>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserHonorAward(response: HttpResponseBase): Observable<UserHonorAndAward> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserHonorAndAward.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserHonorAndAward>(<any>null);
    }

    /**
     * @return Success
     */
    getUserHonorAward(id: number): Observable<UserHonorAndAward> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-user-honor-award/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserHonorAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserHonorAward(<any>response_);
                } catch (e) {
                    return <Observable<UserHonorAndAward>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserHonorAndAward>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserHonorAward(response: HttpResponseBase): Observable<UserHonorAndAward> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserHonorAndAward.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserHonorAndAward>(<any>null);
    }

    /**
     * @return Success
     */
    getAllHonorsAndAwards(): Observable<UserHonorAndAward[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-honors-and-awards";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHonorsAndAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHonorsAndAwards(<any>response_);
                } catch (e) {
                    return <Observable<UserHonorAndAward[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserHonorAndAward[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHonorsAndAwards(response: HttpResponseBase): Observable<UserHonorAndAward[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserHonorAndAward.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserHonorAndAward[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserHonorsAndAwards(userId: number): Observable<UserHonorAndAward[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-user-honors-and-awards/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserHonorsAndAwards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserHonorsAndAwards(<any>response_);
                } catch (e) {
                    return <Observable<UserHonorAndAward[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserHonorAndAward[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserHonorsAndAwards(response: HttpResponseBase): Observable<UserHonorAndAward[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserHonorAndAward.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserHonorAndAward[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserHonorAward(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/delete-user-honor-award/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserHonorAward(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserHonorAward(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserHonorAward(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserJobHistory(body?: UserJobHistory | undefined): Observable<UserJobHistory> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/save-user-job-history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserJobHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserJobHistory(<any>response_);
                } catch (e) {
                    return <Observable<UserJobHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserJobHistory>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserJobHistory(response: HttpResponseBase): Observable<UserJobHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserJobHistory>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserJobHistory(body?: UserJobHistory | undefined): Observable<UserJobHistory> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/update-user-job-history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserJobHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserJobHistory(<any>response_);
                } catch (e) {
                    return <Observable<UserJobHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserJobHistory>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserJobHistory(response: HttpResponseBase): Observable<UserJobHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserJobHistory>(<any>null);
    }

    /**
     * @return Success
     */
    getUserJobHistory(id: number): Observable<UserJobHistory> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-user-job-history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserJobHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserJobHistory(<any>response_);
                } catch (e) {
                    return <Observable<UserJobHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserJobHistory>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserJobHistory(response: HttpResponseBase): Observable<UserJobHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJobHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserJobHistory>(<any>null);
    }

    /**
     * @return Success
     */
    getAllJobHistories(): Observable<UserJobHistory[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-job-histories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobHistories(<any>response_);
                } catch (e) {
                    return <Observable<UserJobHistory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserJobHistory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllJobHistories(response: HttpResponseBase): Observable<UserJobHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserJobHistory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserJobHistory[]>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getAllUserJobHistories(userId?: number | undefined): Observable<UserJobHistory[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-user-job-histories?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserJobHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserJobHistories(<any>response_);
                } catch (e) {
                    return <Observable<UserJobHistory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserJobHistory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserJobHistories(response: HttpResponseBase): Observable<UserJobHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserJobHistory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserJobHistory[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserJobHistory(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/delete-user-job-history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserJobHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserJobHistory(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserJobHistory(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserLinkedIn(body?: UserLinkedIn | undefined): Observable<UserLinkedIn> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/save-user-linked-in";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserLinkedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserLinkedIn(<any>response_);
                } catch (e) {
                    return <Observable<UserLinkedIn>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLinkedIn>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserLinkedIn(response: HttpResponseBase): Observable<UserLinkedIn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLinkedIn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLinkedIn>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserLinkedIn(body?: UserLinkedIn | undefined): Observable<UserLinkedIn> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/update-user-linked-in";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserLinkedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserLinkedIn(<any>response_);
                } catch (e) {
                    return <Observable<UserLinkedIn>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLinkedIn>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserLinkedIn(response: HttpResponseBase): Observable<UserLinkedIn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLinkedIn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLinkedIn>(<any>null);
    }

    /**
     * @return Success
     */
    getUserLinkedIn(id: number): Observable<UserLinkedIn> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-user-linked-in/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserLinkedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserLinkedIn(<any>response_);
                } catch (e) {
                    return <Observable<UserLinkedIn>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLinkedIn>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserLinkedIn(response: HttpResponseBase): Observable<UserLinkedIn> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLinkedIn.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLinkedIn>(<any>null);
    }

    /**
     * @return Success
     */
    getAllLinkedIn(): Observable<UserLinkedIn[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-linked-in";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLinkedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLinkedIn(<any>response_);
                } catch (e) {
                    return <Observable<UserLinkedIn[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserLinkedIn[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLinkedIn(response: HttpResponseBase): Observable<UserLinkedIn[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserLinkedIn.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserLinkedIn[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserLinkedIn(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/delete-user-linked-in/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserLinkedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserLinkedIn(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserLinkedIn(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserProfessionalAssociation(body?: UserProfessionalAssociation | undefined): Observable<UserProfessionalAssociation> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/save-user-professional-association";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserProfessionalAssociation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserProfessionalAssociation(<any>response_);
                } catch (e) {
                    return <Observable<UserProfessionalAssociation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfessionalAssociation>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserProfessionalAssociation(response: HttpResponseBase): Observable<UserProfessionalAssociation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfessionalAssociation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfessionalAssociation>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserProfessionalAssociation(body?: UserProfessionalAssociation | undefined): Observable<UserProfessionalAssociation> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/update-user-professional-association";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserProfessionalAssociation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserProfessionalAssociation(<any>response_);
                } catch (e) {
                    return <Observable<UserProfessionalAssociation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfessionalAssociation>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserProfessionalAssociation(response: HttpResponseBase): Observable<UserProfessionalAssociation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfessionalAssociation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfessionalAssociation>(<any>null);
    }

    /**
     * @return Success
     */
    getUserProfessionalAssociation(id: number): Observable<UserProfessionalAssociation> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-user-professional-association/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfessionalAssociation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfessionalAssociation(<any>response_);
                } catch (e) {
                    return <Observable<UserProfessionalAssociation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfessionalAssociation>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProfessionalAssociation(response: HttpResponseBase): Observable<UserProfessionalAssociation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfessionalAssociation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfessionalAssociation>(<any>null);
    }

    /**
     * @return Success
     */
    getAllProfessionalAssociations(): Observable<UserProfessionalAssociation[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-professional-associations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProfessionalAssociations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProfessionalAssociations(<any>response_);
                } catch (e) {
                    return <Observable<UserProfessionalAssociation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfessionalAssociation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProfessionalAssociations(response: HttpResponseBase): Observable<UserProfessionalAssociation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserProfessionalAssociation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfessionalAssociation[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserProfessionalAssociations(userId: number): Observable<UserProfessionalAssociation[]> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/get-all-user-professional-associations/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserProfessionalAssociations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserProfessionalAssociations(<any>response_);
                } catch (e) {
                    return <Observable<UserProfessionalAssociation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfessionalAssociation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserProfessionalAssociations(response: HttpResponseBase): Observable<UserProfessionalAssociation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserProfessionalAssociation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfessionalAssociation[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserProfessionalAssociation(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/ProfessionalExperiences/delete-user-professional-association/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserProfessionalAssociation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserProfessionalAssociation(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserProfessionalAssociation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveRegistrationOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/save-registration-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRegistrationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRegistrationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveRegistrationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateRegistrationOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/update-registration-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRegistrationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRegistrationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRegistrationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getRegistrationOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/get-registration-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegistrationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegistrationOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegistrationOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllRegistrationOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/get-all-registration-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRegistrationOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRegistrationOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRegistrationOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteRegistrationOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/delete-registration-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegistrationOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegistrationOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRegistrationOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCertificateOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/save-certificate-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCertificateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCertificateOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveCertificateOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCertificateOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/update-certificate-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCertificateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCertificateOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCertificateOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getCertificateOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/get-certificate-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificateOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetCertificateOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCertificateOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/get-all-certificate-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCertificateOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCertificateOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCertificateOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCertificateOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/delete-certificate-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCertificateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCertificateOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCertificateOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveIndustryExperienceOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/save-industry-experience-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveIndustryExperienceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveIndustryExperienceOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processSaveIndustryExperienceOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateIndustryExperienceOption(body?: NamedModel | undefined): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/update-industry-experience-option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIndustryExperienceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIndustryExperienceOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateIndustryExperienceOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getIndustryExperienceOption(id: number): Observable<NamedModel> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/get-industry-experience-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndustryExperienceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndustryExperienceOption(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndustryExperienceOption(response: HttpResponseBase): Observable<NamedModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NamedModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel>(<any>null);
    }

    /**
     * @return Success
     */
    getAllIndustryExperienceOptions(): Observable<NamedModel[]> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/get-all-industry-experience-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIndustryExperienceOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIndustryExperienceOptions(<any>response_);
                } catch (e) {
                    return <Observable<NamedModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NamedModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIndustryExperienceOptions(response: HttpResponseBase): Observable<NamedModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NamedModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NamedModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteIndustryExperienceOption(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/RegistrationCertificationLookups/delete-industry-experience-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIndustryExperienceOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIndustryExperienceOption(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteIndustryExperienceOption(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    getTopStories(): Observable<ExternalResponse> {
        let url_ = this.baseUrl + "/api/RssFeeds/get-top-stories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStories(<any>response_);
                } catch (e) {
                    return <Observable<ExternalResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopStories(response: HttpResponseBase): Observable<ExternalResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getServerEnvironment(): Observable<string> {
        let url_ = this.baseUrl + "/api/ServerInformation/get-server-environment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetServerEnvironment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServerEnvironment(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetServerEnvironment(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body?: User | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/Users/update-user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @return Success
     */
    getUser(id: number): Observable<User> {
        let url_ = this.baseUrl + "/api/Users/get-user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @return Success
     */
    getUserDetails(id: number): Observable<User> {
        let url_ = this.baseUrl + "/api/Users/get-user-details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetails(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDetails(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUsers(): Observable<User[]> {
        let url_ = this.baseUrl + "/api/Users/get-all-users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }

    /**
     * @return Success
     */
    getUsersByClientId(clientId: number): Observable<User[]> {
        let url_ = this.baseUrl + "/api/Users/get-users-by-clientId/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersByClientId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersByClientId(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersByClientId(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUser(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Users/delete-user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveCrd(body?: UserCrd | undefined): Observable<UserCrd> {
        let url_ = this.baseUrl + "/api/UserCrds/save-crd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCrd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCrd(<any>response_);
                } catch (e) {
                    return <Observable<UserCrd>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCrd>><any>_observableThrow(response_);
        }));
    }

    protected processSaveCrd(response: HttpResponseBase): Observable<UserCrd> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCrd.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCrd>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCrd(body?: UserCrd | undefined): Observable<UserCrd> {
        let url_ = this.baseUrl + "/api/UserCrds/update-crd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCrd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCrd(<any>response_);
                } catch (e) {
                    return <Observable<UserCrd>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCrd>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCrd(response: HttpResponseBase): Observable<UserCrd> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCrd.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCrd>(<any>null);
    }

    /**
     * @return Success
     */
    getCrd(id: number): Observable<UserCrd> {
        let url_ = this.baseUrl + "/api/UserCrds/get-crd/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrd(<any>response_);
                } catch (e) {
                    return <Observable<UserCrd>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCrd>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrd(response: HttpResponseBase): Observable<UserCrd> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCrd.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCrd>(<any>null);
    }

    /**
     * @return Success
     */
    getUserCrd(userId: number): Observable<UserCrd> {
        let url_ = this.baseUrl + "/api/UserCrds/get-user-crd/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserCrd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserCrd(<any>response_);
                } catch (e) {
                    return <Observable<UserCrd>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCrd>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserCrd(response: HttpResponseBase): Observable<UserCrd> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCrd.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCrd>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCrds(): Observable<UserCrd[]> {
        let url_ = this.baseUrl + "/api/UserCrds/get-all-crds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCrds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCrds(<any>response_);
                } catch (e) {
                    return <Observable<UserCrd[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCrd[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCrds(response: HttpResponseBase): Observable<UserCrd[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserCrd.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCrd[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteCrd(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserCrds/delete-crd/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCrd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCrd(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCrd(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserClientFocus(body?: UserClientFocus | undefined): Observable<UserClientFocus> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/save-user-client-focus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserClientFocus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserClientFocus(<any>response_);
                } catch (e) {
                    return <Observable<UserClientFocus>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserClientFocus>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserClientFocus(response: HttpResponseBase): Observable<UserClientFocus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserClientFocus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserClientFocus>(<any>null);
    }

    /**
     * @return Success
     */
    getUserClientFocus(id: number): Observable<UserClientFocus> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-user-client-focus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserClientFocus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserClientFocus(<any>response_);
                } catch (e) {
                    return <Observable<UserClientFocus>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserClientFocus>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserClientFocus(response: HttpResponseBase): Observable<UserClientFocus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserClientFocus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserClientFocus>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserClientFocus(userId: number): Observable<UserClientFocus[]> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-all-user-client-focus/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserClientFocus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserClientFocus(<any>response_);
                } catch (e) {
                    return <Observable<UserClientFocus[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserClientFocus[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserClientFocus(response: HttpResponseBase): Observable<UserClientFocus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserClientFocus.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserClientFocus[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserClientFocus(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/delete-user-client-focus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserClientFocus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserClientFocus(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserClientFocus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserContactFrequency(body?: UserContactFrequency | undefined): Observable<UserContactFrequency> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/save-user-contact-frequency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserContactFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserContactFrequency(<any>response_);
                } catch (e) {
                    return <Observable<UserContactFrequency>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserContactFrequency>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserContactFrequency(response: HttpResponseBase): Observable<UserContactFrequency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserContactFrequency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserContactFrequency>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserContactFrequency(body?: UserContactFrequency | undefined): Observable<UserContactFrequency> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/update-user-contact-frequency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserContactFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserContactFrequency(<any>response_);
                } catch (e) {
                    return <Observable<UserContactFrequency>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserContactFrequency>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserContactFrequency(response: HttpResponseBase): Observable<UserContactFrequency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserContactFrequency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserContactFrequency>(<any>null);
    }

    /**
     * @return Success
     */
    getUserContactFrequency(id: number): Observable<UserContactFrequency> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-user-contact-frequency/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserContactFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserContactFrequency(<any>response_);
                } catch (e) {
                    return <Observable<UserContactFrequency>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserContactFrequency>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserContactFrequency(response: HttpResponseBase): Observable<UserContactFrequency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserContactFrequency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserContactFrequency>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserContactFrequency(userId: number): Observable<UserContactFrequency[]> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-all-user-contact-frequency/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserContactFrequency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserContactFrequency(<any>response_);
                } catch (e) {
                    return <Observable<UserContactFrequency[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserContactFrequency[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserContactFrequency(response: HttpResponseBase): Observable<UserContactFrequency[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserContactFrequency.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserContactFrequency[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserContactTime(body?: UserContactTime | undefined): Observable<UserContactTime> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/save-user-contact-time";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserContactTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserContactTime(<any>response_);
                } catch (e) {
                    return <Observable<UserContactTime>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserContactTime>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserContactTime(response: HttpResponseBase): Observable<UserContactTime> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserContactTime.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserContactTime>(<any>null);
    }

    /**
     * @return Success
     */
    getUserContactTime(id: number): Observable<UserContactTime> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-user-contact-time/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserContactTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserContactTime(<any>response_);
                } catch (e) {
                    return <Observable<UserContactTime>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserContactTime>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserContactTime(response: HttpResponseBase): Observable<UserContactTime> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserContactTime.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserContactTime>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserContactTime(userId: number): Observable<UserContactTime[]> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-all-user-contact-time/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserContactTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserContactTime(<any>response_);
                } catch (e) {
                    return <Observable<UserContactTime[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserContactTime[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserContactTime(response: HttpResponseBase): Observable<UserContactTime[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserContactTime.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserContactTime[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserContactTime(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/delete-user-contact-time/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserContactTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserContactTime(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserContactTime(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserDesiredSolution(body?: UserDesiredSolutionService | undefined): Observable<UserDesiredSolutionService> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/save-user-desired-solution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserDesiredSolution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserDesiredSolution(<any>response_);
                } catch (e) {
                    return <Observable<UserDesiredSolutionService>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDesiredSolutionService>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserDesiredSolution(response: HttpResponseBase): Observable<UserDesiredSolutionService> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDesiredSolutionService.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDesiredSolutionService>(<any>null);
    }

    /**
     * @return Success
     */
    getUserDesiredSolution(id: number): Observable<UserDesiredSolutionService> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-user-desired-solution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDesiredSolution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDesiredSolution(<any>response_);
                } catch (e) {
                    return <Observable<UserDesiredSolutionService>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDesiredSolutionService>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDesiredSolution(response: HttpResponseBase): Observable<UserDesiredSolutionService> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDesiredSolutionService.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDesiredSolutionService>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserDesiredSolution(userId: number): Observable<UserDesiredSolutionService[]> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-all-user-desired-solution/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserDesiredSolution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserDesiredSolution(<any>response_);
                } catch (e) {
                    return <Observable<UserDesiredSolutionService[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDesiredSolutionService[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserDesiredSolution(response: HttpResponseBase): Observable<UserDesiredSolutionService[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDesiredSolutionService.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDesiredSolutionService[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserDesiredSolution(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/delete-user-desired-solution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserDesiredSolution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserDesiredSolution(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserDesiredSolution(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserInvestmentImplementation(body?: UserInvestmentImplementation | undefined): Observable<UserInvestmentImplementation> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/save-user-investment-implementation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserInvestmentImplementation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserInvestmentImplementation(<any>response_);
                } catch (e) {
                    return <Observable<UserInvestmentImplementation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInvestmentImplementation>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserInvestmentImplementation(response: HttpResponseBase): Observable<UserInvestmentImplementation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInvestmentImplementation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInvestmentImplementation>(<any>null);
    }

    /**
     * @return Success
     */
    getUserInvestmentImplementation(id: number): Observable<UserInvestmentImplementation> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-user-investment-implementation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInvestmentImplementation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInvestmentImplementation(<any>response_);
                } catch (e) {
                    return <Observable<UserInvestmentImplementation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInvestmentImplementation>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInvestmentImplementation(response: HttpResponseBase): Observable<UserInvestmentImplementation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInvestmentImplementation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInvestmentImplementation>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserInvestmentImplementation(userId: number): Observable<UserInvestmentImplementation[]> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-all-user-investment-implementation/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserInvestmentImplementation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserInvestmentImplementation(<any>response_);
                } catch (e) {
                    return <Observable<UserInvestmentImplementation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInvestmentImplementation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserInvestmentImplementation(response: HttpResponseBase): Observable<UserInvestmentImplementation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInvestmentImplementation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInvestmentImplementation[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserInvestmentImplementation(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/delete-user-investment-implementation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserInvestmentImplementation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserInvestmentImplementation(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserInvestmentImplementation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserPreferredEngagement(body?: UserPreferredEngagement | undefined): Observable<UserPreferredEngagement> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/save-user-preferred-engagement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserPreferredEngagement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserPreferredEngagement(<any>response_);
                } catch (e) {
                    return <Observable<UserPreferredEngagement>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPreferredEngagement>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserPreferredEngagement(response: HttpResponseBase): Observable<UserPreferredEngagement> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPreferredEngagement.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPreferredEngagement>(<any>null);
    }

    /**
     * @return Success
     */
    getUserPreferredEngagement(id: number): Observable<UserPreferredEngagement> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-user-preferred-engagement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPreferredEngagement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPreferredEngagement(<any>response_);
                } catch (e) {
                    return <Observable<UserPreferredEngagement>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPreferredEngagement>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPreferredEngagement(response: HttpResponseBase): Observable<UserPreferredEngagement> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPreferredEngagement.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPreferredEngagement>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserPreferredEngagement(userId: number): Observable<UserPreferredEngagement[]> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/get-all-user-preferred-engagement/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserPreferredEngagement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserPreferredEngagement(<any>response_);
                } catch (e) {
                    return <Observable<UserPreferredEngagement[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPreferredEngagement[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserPreferredEngagement(response: HttpResponseBase): Observable<UserPreferredEngagement[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserPreferredEngagement.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPreferredEngagement[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserPreferredEngagement(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserEngagementLookups/delete-user-preferred-engagement/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserPreferredEngagement(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserPreferredEngagement(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserPreferredEngagement(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserAllocation(body?: UserAllocation | undefined): Observable<UserAllocation> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-allocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserAllocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserAllocation(<any>response_);
                } catch (e) {
                    return <Observable<UserAllocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAllocation>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserAllocation(response: HttpResponseBase): Observable<UserAllocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAllocation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAllocation>(<any>null);
    }

    /**
     * @return Success
     */
    getUserAllocation(id: number): Observable<UserAllocation> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-allocation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAllocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAllocation(<any>response_);
                } catch (e) {
                    return <Observable<UserAllocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAllocation>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAllocation(response: HttpResponseBase): Observable<UserAllocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAllocation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAllocation>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserAllocations(userId: number): Observable<UserAllocation[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-user-allocations/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserAllocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserAllocations(<any>response_);
                } catch (e) {
                    return <Observable<UserAllocation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAllocation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserAllocations(response: HttpResponseBase): Observable<UserAllocation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAllocation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAllocation[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserAllocation(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-allocation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserAllocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserAllocation(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserAllocation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserAlternative(body?: UserAlternative | undefined): Observable<UserAlternative> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-alternative";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserAlternative(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserAlternative(<any>response_);
                } catch (e) {
                    return <Observable<UserAlternative>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAlternative>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserAlternative(response: HttpResponseBase): Observable<UserAlternative> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAlternative.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAlternative>(<any>null);
    }

    /**
     * @return Success
     */
    getUserAlternative(id: number): Observable<UserAlternative> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-alternative/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAlternative(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAlternative(<any>response_);
                } catch (e) {
                    return <Observable<UserAlternative>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAlternative>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAlternative(response: HttpResponseBase): Observable<UserAlternative> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAlternative.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAlternative>(<any>null);
    }

    /**
     * @return Success
     */
    getUserAllAlternatives(userId: number): Observable<UserAlternative[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-all-alternatives/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAllAlternatives(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAllAlternatives(<any>response_);
                } catch (e) {
                    return <Observable<UserAlternative[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAlternative[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAllAlternatives(response: HttpResponseBase): Observable<UserAlternative[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAlternative.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAlternative[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserAlternative(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-alternative/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserAlternative(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserAlternative(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserAlternative(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserCommodity(body?: UserCommodity | undefined): Observable<UserCommodity> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-commodity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserCommodity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserCommodity(<any>response_);
                } catch (e) {
                    return <Observable<UserCommodity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCommodity>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserCommodity(response: HttpResponseBase): Observable<UserCommodity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCommodity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCommodity>(<any>null);
    }

    /**
     * @return Success
     */
    getUserCommodity(id: number): Observable<UserCommodity> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-commodity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserCommodity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserCommodity(<any>response_);
                } catch (e) {
                    return <Observable<UserCommodity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCommodity>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserCommodity(response: HttpResponseBase): Observable<UserCommodity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCommodity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCommodity>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCommodities(userId: number): Observable<UserCommodity[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-commodities/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCommodities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCommodities(<any>response_);
                } catch (e) {
                    return <Observable<UserCommodity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCommodity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCommodities(response: HttpResponseBase): Observable<UserCommodity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserCommodity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCommodity[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserCommodity(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-commodity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserCommodity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserCommodity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserCommodity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserEquity(body?: UserEquity | undefined): Observable<UserEquity> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-equity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserEquity(<any>response_);
                } catch (e) {
                    return <Observable<UserEquity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEquity>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserEquity(response: HttpResponseBase): Observable<UserEquity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEquity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEquity>(<any>null);
    }

    /**
     * @return Success
     */
    getUserEquity(id: number): Observable<UserEquity> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-equity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserEquity(<any>response_);
                } catch (e) {
                    return <Observable<UserEquity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEquity>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserEquity(response: HttpResponseBase): Observable<UserEquity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserEquity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEquity>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserEquities(userId: number): Observable<UserEquity[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-user-equities/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserEquities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserEquities(<any>response_);
                } catch (e) {
                    return <Observable<UserEquity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserEquity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserEquities(response: HttpResponseBase): Observable<UserEquity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserEquity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserEquity[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserEquity(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-equity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserEquity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserEquity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserInternationalEquity(body?: UserInternationalEquity | undefined): Observable<UserInternationalEquity> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-international-equity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserInternationalEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserInternationalEquity(<any>response_);
                } catch (e) {
                    return <Observable<UserInternationalEquity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInternationalEquity>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserInternationalEquity(response: HttpResponseBase): Observable<UserInternationalEquity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInternationalEquity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInternationalEquity>(<any>null);
    }

    /**
     * @return Success
     */
    getUserInternationalEquity(id: number): Observable<UserInternationalEquity> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-international-equity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInternationalEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInternationalEquity(<any>response_);
                } catch (e) {
                    return <Observable<UserInternationalEquity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInternationalEquity>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInternationalEquity(response: HttpResponseBase): Observable<UserInternationalEquity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInternationalEquity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInternationalEquity>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserInternationalEquities(userId: number): Observable<UserInternationalEquity[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-user-international-equities/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserInternationalEquities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserInternationalEquities(<any>response_);
                } catch (e) {
                    return <Observable<UserInternationalEquity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInternationalEquity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserInternationalEquities(response: HttpResponseBase): Observable<UserInternationalEquity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserInternationalEquity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInternationalEquity[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserInternationalEquity(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-international-equity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserInternationalEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserInternationalEquity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserInternationalEquity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserMoneyMarket(body?: UserMoneyMarket | undefined): Observable<UserMoneyMarket> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-money-market";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserMoneyMarket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserMoneyMarket(<any>response_);
                } catch (e) {
                    return <Observable<UserMoneyMarket>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserMoneyMarket>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserMoneyMarket(response: HttpResponseBase): Observable<UserMoneyMarket> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserMoneyMarket.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMoneyMarket>(<any>null);
    }

    /**
     * @return Success
     */
    getUserMoneyMarket(id: number): Observable<UserMoneyMarket> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-money-market/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserMoneyMarket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserMoneyMarket(<any>response_);
                } catch (e) {
                    return <Observable<UserMoneyMarket>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserMoneyMarket>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserMoneyMarket(response: HttpResponseBase): Observable<UserMoneyMarket> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserMoneyMarket.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMoneyMarket>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserMoneyMarkets(userId: number): Observable<UserMoneyMarket[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-user-money-markets/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserMoneyMarkets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserMoneyMarkets(<any>response_);
                } catch (e) {
                    return <Observable<UserMoneyMarket[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserMoneyMarket[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserMoneyMarkets(response: HttpResponseBase): Observable<UserMoneyMarket[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserMoneyMarket.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMoneyMarket[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserMoneyMarket(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-money-market/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserMoneyMarket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserMoneyMarket(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserMoneyMarket(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserMunicipalBond(body?: UserMunicipalBond | undefined): Observable<UserMunicipalBond> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-municipal-bond";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserMunicipalBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserMunicipalBond(<any>response_);
                } catch (e) {
                    return <Observable<UserMunicipalBond>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserMunicipalBond>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserMunicipalBond(response: HttpResponseBase): Observable<UserMunicipalBond> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserMunicipalBond.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMunicipalBond>(<any>null);
    }

    /**
     * @return Success
     */
    getUserMunicipalBond(id: number): Observable<UserMunicipalBond> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-municipal-bond/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserMunicipalBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserMunicipalBond(<any>response_);
                } catch (e) {
                    return <Observable<UserMunicipalBond>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserMunicipalBond>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserMunicipalBond(response: HttpResponseBase): Observable<UserMunicipalBond> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserMunicipalBond.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMunicipalBond>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserMunicipalBonds(userId: number): Observable<UserMunicipalBond[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-user-municipal-bonds/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserMunicipalBonds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserMunicipalBonds(<any>response_);
                } catch (e) {
                    return <Observable<UserMunicipalBond[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserMunicipalBond[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserMunicipalBonds(response: HttpResponseBase): Observable<UserMunicipalBond[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserMunicipalBond.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserMunicipalBond[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserMunicipalBond(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-municipal-bond/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserMunicipalBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserMunicipalBond(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserMunicipalBond(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserProduct(body?: UserProduct | undefined): Observable<UserProduct> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserProduct(<any>response_);
                } catch (e) {
                    return <Observable<UserProduct>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProduct>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserProduct(response: HttpResponseBase): Observable<UserProduct> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProduct.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProduct>(<any>null);
    }

    /**
     * @return Success
     */
    getUserProduct(id: number): Observable<UserProduct> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProduct(<any>response_);
                } catch (e) {
                    return <Observable<UserProduct>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProduct>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserProduct(response: HttpResponseBase): Observable<UserProduct> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProduct.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProduct>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserProducts(userId: number): Observable<UserProduct[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-user-products/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserProducts(<any>response_);
                } catch (e) {
                    return <Observable<UserProduct[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProduct[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserProducts(response: HttpResponseBase): Observable<UserProduct[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserProduct.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProduct[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserProduct(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserProduct(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserProduct(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserSectorEquity(body?: UserSectorEquity | undefined): Observable<UserSectorEquity> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-sector-equity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserSectorEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserSectorEquity(<any>response_);
                } catch (e) {
                    return <Observable<UserSectorEquity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSectorEquity>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserSectorEquity(response: HttpResponseBase): Observable<UserSectorEquity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSectorEquity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSectorEquity>(<any>null);
    }

    /**
     * @return Success
     */
    getUserSectorEquity(id: number): Observable<UserSectorEquity> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-sector-equity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserSectorEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserSectorEquity(<any>response_);
                } catch (e) {
                    return <Observable<UserSectorEquity>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSectorEquity>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserSectorEquity(response: HttpResponseBase): Observable<UserSectorEquity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSectorEquity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSectorEquity>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserSectorEquities(userId: number): Observable<UserSectorEquity[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-user-sector-equities/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserSectorEquities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserSectorEquities(<any>response_);
                } catch (e) {
                    return <Observable<UserSectorEquity[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserSectorEquity[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserSectorEquities(response: HttpResponseBase): Observable<UserSectorEquity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserSectorEquity.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserSectorEquity[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserSectorEquity(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-sector-equity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserSectorEquity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserSectorEquity(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserSectorEquity(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserTaxableBond(body?: UserTaxableBond | undefined): Observable<UserTaxableBond> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/save-user-taxable-bond";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserTaxableBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserTaxableBond(<any>response_);
                } catch (e) {
                    return <Observable<UserTaxableBond>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTaxableBond>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserTaxableBond(response: HttpResponseBase): Observable<UserTaxableBond> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTaxableBond.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTaxableBond>(<any>null);
    }

    /**
     * @return Success
     */
    getUserTaxableBond(id: number): Observable<UserTaxableBond> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-user-taxable-bond/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTaxableBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTaxableBond(<any>response_);
                } catch (e) {
                    return <Observable<UserTaxableBond>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTaxableBond>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserTaxableBond(response: HttpResponseBase): Observable<UserTaxableBond> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTaxableBond.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTaxableBond>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserTaxableBonds(userId: number): Observable<UserTaxableBond[]> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/get-all-user-taxable-bonds/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserTaxableBonds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserTaxableBonds(<any>response_);
                } catch (e) {
                    return <Observable<UserTaxableBond[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTaxableBond[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserTaxableBonds(response: HttpResponseBase): Observable<UserTaxableBond[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserTaxableBond.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTaxableBond[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserTaxableBond(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserInvestmentUitilizationLookups/delete-user-taxable-bond/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserTaxableBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserTaxableBond(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserTaxableBond(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveProfilePicture(body?: UserProfilePicture | undefined): Observable<UserProfilePicture> {
        let url_ = this.baseUrl + "/api/UserProfiles/save-profile-picture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<UserProfilePicture>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfilePicture>><any>_observableThrow(response_);
        }));
    }

    protected processSaveProfilePicture(response: HttpResponseBase): Observable<UserProfilePicture> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfilePicture.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfilePicture>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body?: UserProfilePicture | undefined): Observable<UserProfilePicture> {
        let url_ = this.baseUrl + "/api/UserProfiles/update-profile-picture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<UserProfilePicture>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfilePicture>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<UserProfilePicture> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfilePicture.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfilePicture>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(userId: number): Observable<UserProfilePicture> {
        let url_ = this.baseUrl + "/api/UserProfiles/get-profile-picture/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<UserProfilePicture>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfilePicture>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<UserProfilePicture> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfilePicture.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfilePicture>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProfilePicture(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserProfiles/delete-profile-picture/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProfilePicture(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserRegistration(body?: UserRegistration | undefined): Observable<UserRegistration> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/save-user-registration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserRegistration(<any>response_);
                } catch (e) {
                    return <Observable<UserRegistration>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRegistration>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserRegistration(response: HttpResponseBase): Observable<UserRegistration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRegistration.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRegistration>(<any>null);
    }

    /**
     * @return Success
     */
    getUserRegistration(id: number): Observable<UserRegistration> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/get-user-registration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRegistration(<any>response_);
                } catch (e) {
                    return <Observable<UserRegistration>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRegistration>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserRegistration(response: HttpResponseBase): Observable<UserRegistration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRegistration.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRegistration>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserRegistration(userId: number): Observable<UserRegistration[]> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/get-all-user-registration/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserRegistration(<any>response_);
                } catch (e) {
                    return <Observable<UserRegistration[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserRegistration[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserRegistration(response: HttpResponseBase): Observable<UserRegistration[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserRegistration.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserRegistration[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserRegistration(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/delete-user-registration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserRegistration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserRegistration(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserRegistration(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserCertification(body?: UserCertification | undefined): Observable<UserCertification> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/save-user-certification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserCertification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserCertification(<any>response_);
                } catch (e) {
                    return <Observable<UserCertification>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCertification>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserCertification(response: HttpResponseBase): Observable<UserCertification> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCertification.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCertification>(<any>null);
    }

    /**
     * @return Success
     */
    getUserCertification(id: number): Observable<UserCertification> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/get-user-certification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserCertification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserCertification(<any>response_);
                } catch (e) {
                    return <Observable<UserCertification>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCertification>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserCertification(response: HttpResponseBase): Observable<UserCertification> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserCertification.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCertification>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserCertification(userId: number): Observable<UserCertification[]> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/get-all-user-certification/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserCertification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserCertification(<any>response_);
                } catch (e) {
                    return <Observable<UserCertification[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserCertification[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserCertification(response: HttpResponseBase): Observable<UserCertification[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserCertification.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserCertification[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUserCertification(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/delete-user-certification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserCertification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserCertification(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserCertification(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserIndustryExperience(body?: UserIndustryExperience | undefined): Observable<UserIndustryExperience> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/save-user-industry-experience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserIndustryExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserIndustryExperience(<any>response_);
                } catch (e) {
                    return <Observable<UserIndustryExperience>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserIndustryExperience>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserIndustryExperience(response: HttpResponseBase): Observable<UserIndustryExperience> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserIndustryExperience.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserIndustryExperience>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserIndustryExperience2(body?: UserIndustryExperience | undefined): Observable<UserIndustryExperience> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/save-user-industry-experience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserIndustryExperience2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserIndustryExperience2(<any>response_);
                } catch (e) {
                    return <Observable<UserIndustryExperience>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserIndustryExperience>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserIndustryExperience2(response: HttpResponseBase): Observable<UserIndustryExperience> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserIndustryExperience.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserIndustryExperience>(<any>null);
    }

    /**
     * @return Success
     */
    getUserIndustryExperience(id: number): Observable<UserIndustryExperience> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/get-user-industry-experience/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserIndustryExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserIndustryExperience(<any>response_);
                } catch (e) {
                    return <Observable<UserIndustryExperience>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserIndustryExperience>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserIndustryExperience(response: HttpResponseBase): Observable<UserIndustryExperience> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserIndustryExperience.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserIndustryExperience>(<any>null);
    }

    /**
     * @return Success
     */
    getAllUserIndustryExperience(userId: number): Observable<UserIndustryExperience[]> {
        let url_ = this.baseUrl + "/api/UserRegistrationCertificationLookups/get-all-user-industry-experience/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserIndustryExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserIndustryExperience(<any>response_);
                } catch (e) {
                    return <Observable<UserIndustryExperience[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserIndustryExperience[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserIndustryExperience(response: HttpResponseBase): Observable<UserIndustryExperience[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserIndustryExperience.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserIndustryExperience[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveReviewer(body?: UserTeamReviewer | undefined): Observable<UserTeamReviewer> {
        let url_ = this.baseUrl + "/api/UserReviewManagers/save-reviewer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveReviewer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveReviewer(<any>response_);
                } catch (e) {
                    return <Observable<UserTeamReviewer>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTeamReviewer>><any>_observableThrow(response_);
        }));
    }

    protected processSaveReviewer(response: HttpResponseBase): Observable<UserTeamReviewer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTeamReviewer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTeamReviewer>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReviewer(body?: UserTeamReviewer | undefined): Observable<UserTeamReviewer> {
        let url_ = this.baseUrl + "/api/UserReviewManagers/update-reviewer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReviewer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReviewer(<any>response_);
                } catch (e) {
                    return <Observable<UserTeamReviewer>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTeamReviewer>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateReviewer(response: HttpResponseBase): Observable<UserTeamReviewer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTeamReviewer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTeamReviewer>(<any>null);
    }

    /**
     * @return Success
     */
    getReviewer(id: number): Observable<UserTeamReviewer> {
        let url_ = this.baseUrl + "/api/UserReviewManagers/get-reviewer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReviewer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReviewer(<any>response_);
                } catch (e) {
                    return <Observable<UserTeamReviewer>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTeamReviewer>><any>_observableThrow(response_);
        }));
    }

    protected processGetReviewer(response: HttpResponseBase): Observable<UserTeamReviewer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTeamReviewer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTeamReviewer>(<any>null);
    }

    /**
     * @return Success
     */
    getUserReviewer(userId: number): Observable<UserTeamReviewer> {
        let url_ = this.baseUrl + "/api/UserReviewManagers/get-user-reviewer/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserReviewer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserReviewer(<any>response_);
                } catch (e) {
                    return <Observable<UserTeamReviewer>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTeamReviewer>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserReviewer(response: HttpResponseBase): Observable<UserTeamReviewer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTeamReviewer.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTeamReviewer>(<any>null);
    }

    /**
     * @return Success
     */
    getAllReviewers(): Observable<UserTeamReviewer[]> {
        let url_ = this.baseUrl + "/api/UserReviewManagers/get-all-reviewers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllReviewers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllReviewers(<any>response_);
                } catch (e) {
                    return <Observable<UserTeamReviewer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserTeamReviewer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllReviewers(response: HttpResponseBase): Observable<UserTeamReviewer[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserTeamReviewer.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserTeamReviewer[]>(<any>null);
    }

    /**
     * @return Success
     */
    deleteReviewer(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/UserReviewManagers/delete-reviewer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReviewer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReviewer(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteReviewer(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export class LoginModel implements ILoginModel {
    emailAddress?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginModel {
    emailAddress?: string | undefined;
    password?: string | undefined;
}

export class LoginToken implements ILoginToken {
    id?: number;
    first_Name?: string | undefined;
    last_Name?: string | undefined;
    email_Address?: string | undefined;
    clientId?: number;
    token?: string | undefined;
    expires_At?: Date;

    constructor(data?: ILoginToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.first_Name = _data["first_Name"];
            this.last_Name = _data["last_Name"];
            this.email_Address = _data["email_Address"];
            this.clientId = _data["clientId"];
            this.token = _data["token"];
            this.expires_At = _data["expires_At"] ? new Date(_data["expires_At"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginToken {
        data = typeof data === 'object' ? data : {};
        let result = new LoginToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["first_Name"] = this.first_Name;
        data["last_Name"] = this.last_Name;
        data["email_Address"] = this.email_Address;
        data["clientId"] = this.clientId;
        data["token"] = this.token;
        data["expires_At"] = this.expires_At ? this.expires_At.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ILoginToken {
    id?: number;
    first_Name?: string | undefined;
    last_Name?: string | undefined;
    email_Address?: string | undefined;
    clientId?: number;
    token?: string | undefined;
    expires_At?: Date;
}

export class NamedModel implements INamedModel {
    id?: number;
    name?: string | undefined;

    constructor(data?: INamedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): NamedModel {
        data = typeof data === 'object' ? data : {};
        let result = new NamedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface INamedModel {
    id?: number;
    name?: string | undefined;
}

export class UserAddress implements IUserAddress {
    id?: number;
    user_Id?: number;
    street_Address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zipcode?: string | undefined;
    user?: User;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.street_Address = _data["street_Address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zipcode = _data["zipcode"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["street_Address"] = this.street_Address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipcode"] = this.zipcode;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserAddress {
    id?: number;
    user_Id?: number;
    street_Address?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    country?: string | undefined;
    zipcode?: string | undefined;
    user?: User;
}

export class Client implements IClient {
    id?: number;
    name?: string | undefined;
    users?: User[] | undefined;
    tagline?: string | undefined;

    constructor(data?: IClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
            this.tagline = _data["tagline"];
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["tagline"] = this.tagline;
        return data; 
    }
}

export interface IClient {
    id?: number;
    name?: string | undefined;
    users?: User[] | undefined;
    tagline?: string | undefined;
}

export class UserProfilePicture implements IUserProfilePicture {
    id?: number;
    image_Type?: string | undefined;
    picture?: string | undefined;

    constructor(data?: IUserProfilePicture) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.image_Type = _data["image_Type"];
            this.picture = _data["picture"];
        }
    }

    static fromJS(data: any): UserProfilePicture {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfilePicture();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["image_Type"] = this.image_Type;
        data["picture"] = this.picture;
        return data; 
    }
}

export interface IUserProfilePicture {
    id?: number;
    image_Type?: string | undefined;
    picture?: string | undefined;
}

export class User implements IUser {
    id?: number;
    client_Id?: number;
    email_Address?: string | undefined;
    password?: string | undefined;
    permission_Id?: number;
    first_Name?: string | undefined;
    last_Name?: string | undefined;
    company_Name?: string | undefined;
    phone_Number?: string | undefined;
    job_Title?: string | undefined;
    permission?: NamedModel;
    address?: UserAddress;
    client?: Client;
    profilePicture?: UserProfilePicture;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.client_Id = _data["client_Id"];
            this.email_Address = _data["email_Address"];
            this.password = _data["password"];
            this.permission_Id = _data["permission_Id"];
            this.first_Name = _data["first_Name"];
            this.last_Name = _data["last_Name"];
            this.company_Name = _data["company_Name"];
            this.phone_Number = _data["phone_Number"];
            this.job_Title = _data["job_Title"];
            this.permission = _data["permission"] ? NamedModel.fromJS(_data["permission"]) : <any>undefined;
            this.address = _data["address"] ? UserAddress.fromJS(_data["address"]) : <any>undefined;
            this.client = _data["client"] ? Client.fromJS(_data["client"]) : <any>undefined;
            this.profilePicture = _data["profilePicture"] ? UserProfilePicture.fromJS(_data["profilePicture"]) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["client_Id"] = this.client_Id;
        data["email_Address"] = this.email_Address;
        data["password"] = this.password;
        data["permission_Id"] = this.permission_Id;
        data["first_Name"] = this.first_Name;
        data["last_Name"] = this.last_Name;
        data["company_Name"] = this.company_Name;
        data["phone_Number"] = this.phone_Number;
        data["job_Title"] = this.job_Title;
        data["permission"] = this.permission ? this.permission.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["profilePicture"] = this.profilePicture ? this.profilePicture.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUser {
    id?: number;
    client_Id?: number;
    email_Address?: string | undefined;
    password?: string | undefined;
    permission_Id?: number;
    first_Name?: string | undefined;
    last_Name?: string | undefined;
    company_Name?: string | undefined;
    phone_Number?: string | undefined;
    job_Title?: string | undefined;
    permission?: NamedModel;
    address?: UserAddress;
    client?: Client;
    profilePicture?: UserProfilePicture;
}

export class EmailModel implements IEmailModel {
    email?: string | undefined;

    constructor(data?: IEmailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): EmailModel {
        data = typeof data === 'object' ? data : {};
        let result = new EmailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }
}

export interface IEmailModel {
    email?: string | undefined;
}

export class PasswordModel implements IPasswordModel {
    code?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IPasswordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): PasswordModel {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IPasswordModel {
    code?: string | undefined;
    newPassword?: string | undefined;
}

export class CountryState implements ICountryState {
    id?: number;
    long_Name?: string | undefined;
    short_Name?: string | undefined;
    country_Id?: number;

    constructor(data?: ICountryState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.long_Name = _data["long_Name"];
            this.short_Name = _data["short_Name"];
            this.country_Id = _data["country_Id"];
        }
    }

    static fromJS(data: any): CountryState {
        data = typeof data === 'object' ? data : {};
        let result = new CountryState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["long_Name"] = this.long_Name;
        data["short_Name"] = this.short_Name;
        data["country_Id"] = this.country_Id;
        return data; 
    }
}

export interface ICountryState {
    id?: number;
    long_Name?: string | undefined;
    short_Name?: string | undefined;
    country_Id?: number;
}

export class UserBiography implements IUserBiography {
    id?: number;
    user_Id?: number;
    user?: User;
    description?: string | undefined;

    constructor(data?: IUserBiography) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UserBiography {
        data = typeof data === 'object' ? data : {};
        let result = new UserBiography();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUserBiography {
    id?: number;
    user_Id?: number;
    user?: User;
    description?: string | undefined;
}

export class UserEducation implements IUserEducation {
    id?: number;
    user_Id?: number;
    user?: User;
    city?: string | undefined;
    state_Id?: number | undefined;
    state?: CountryState;
    country_Id?: number;
    country?: NamedModel;
    school?: string | undefined;
    degree?: string | undefined;
    degree_Year?: number | undefined;
    fields_Of_Study?: string | undefined;
    year_From?: number;
    year_To?: number | undefined;
    dissertation?: string | undefined;
    advisor?: string | undefined;
    is_Highest?: boolean | undefined;
    has_Country_States?: boolean | undefined;

    constructor(data?: IUserEducation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.city = _data["city"];
            this.state_Id = _data["state_Id"];
            this.state = _data["state"] ? CountryState.fromJS(_data["state"]) : <any>undefined;
            this.country_Id = _data["country_Id"];
            this.country = _data["country"] ? NamedModel.fromJS(_data["country"]) : <any>undefined;
            this.school = _data["school"];
            this.degree = _data["degree"];
            this.degree_Year = _data["degree_Year"];
            this.fields_Of_Study = _data["fields_Of_Study"];
            this.year_From = _data["year_From"];
            this.year_To = _data["year_To"];
            this.dissertation = _data["dissertation"];
            this.advisor = _data["advisor"];
            this.is_Highest = _data["is_Highest"];
            this.has_Country_States = _data["has_Country_States"];
        }
    }

    static fromJS(data: any): UserEducation {
        data = typeof data === 'object' ? data : {};
        let result = new UserEducation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["city"] = this.city;
        data["state_Id"] = this.state_Id;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["country_Id"] = this.country_Id;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["school"] = this.school;
        data["degree"] = this.degree;
        data["degree_Year"] = this.degree_Year;
        data["fields_Of_Study"] = this.fields_Of_Study;
        data["year_From"] = this.year_From;
        data["year_To"] = this.year_To;
        data["dissertation"] = this.dissertation;
        data["advisor"] = this.advisor;
        data["is_Highest"] = this.is_Highest;
        data["has_Country_States"] = this.has_Country_States;
        return data; 
    }
}

export interface IUserEducation {
    id?: number;
    user_Id?: number;
    user?: User;
    city?: string | undefined;
    state_Id?: number | undefined;
    state?: CountryState;
    country_Id?: number;
    country?: NamedModel;
    school?: string | undefined;
    degree?: string | undefined;
    degree_Year?: number | undefined;
    fields_Of_Study?: string | undefined;
    year_From?: number;
    year_To?: number | undefined;
    dissertation?: string | undefined;
    advisor?: string | undefined;
    is_Highest?: boolean | undefined;
    has_Country_States?: boolean | undefined;
}

export class UserHonorAndAward implements IUserHonorAndAward {
    id?: number;
    user_Id?: number;
    user?: User;
    award_Name?: string | undefined;
    award_Organization?: string | undefined;
    acronym?: string | undefined;
    years?: string | undefined;

    constructor(data?: IUserHonorAndAward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.award_Name = _data["award_Name"];
            this.award_Organization = _data["award_Organization"];
            this.acronym = _data["acronym"];
            this.years = _data["years"];
        }
    }

    static fromJS(data: any): UserHonorAndAward {
        data = typeof data === 'object' ? data : {};
        let result = new UserHonorAndAward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["award_Name"] = this.award_Name;
        data["award_Organization"] = this.award_Organization;
        data["acronym"] = this.acronym;
        data["years"] = this.years;
        return data; 
    }
}

export interface IUserHonorAndAward {
    id?: number;
    user_Id?: number;
    user?: User;
    award_Name?: string | undefined;
    award_Organization?: string | undefined;
    acronym?: string | undefined;
    years?: string | undefined;
}

export class UserJobHistory implements IUserJobHistory {
    id?: number;
    user_Id?: number;
    user?: User;
    company_Name?: string | undefined;
    title?: string | undefined;
    city?: string | undefined;
    state_Id?: number | undefined;
    state?: CountryState;
    country_Id?: number;
    country?: NamedModel;
    start_Date?: Date;
    end_Date?: Date | undefined;
    web_Address?: string | undefined;
    is_Present?: boolean | undefined;
    has_Country_States?: boolean | undefined;

    constructor(data?: IUserJobHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.company_Name = _data["company_Name"];
            this.title = _data["title"];
            this.city = _data["city"];
            this.state_Id = _data["state_Id"];
            this.state = _data["state"] ? CountryState.fromJS(_data["state"]) : <any>undefined;
            this.country_Id = _data["country_Id"];
            this.country = _data["country"] ? NamedModel.fromJS(_data["country"]) : <any>undefined;
            this.start_Date = _data["start_Date"] ? new Date(_data["start_Date"].toString()) : <any>undefined;
            this.end_Date = _data["end_Date"] ? new Date(_data["end_Date"].toString()) : <any>undefined;
            this.web_Address = _data["web_Address"];
            this.is_Present = _data["is_Present"];
            this.has_Country_States = _data["has_Country_States"];
        }
    }

    static fromJS(data: any): UserJobHistory {
        data = typeof data === 'object' ? data : {};
        let result = new UserJobHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["company_Name"] = this.company_Name;
        data["title"] = this.title;
        data["city"] = this.city;
        data["state_Id"] = this.state_Id;
        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
        data["country_Id"] = this.country_Id;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["start_Date"] = this.start_Date ? this.start_Date.toISOString() : <any>undefined;
        data["end_Date"] = this.end_Date ? this.end_Date.toISOString() : <any>undefined;
        data["web_Address"] = this.web_Address;
        data["is_Present"] = this.is_Present;
        data["has_Country_States"] = this.has_Country_States;
        return data; 
    }
}

export interface IUserJobHistory {
    id?: number;
    user_Id?: number;
    user?: User;
    company_Name?: string | undefined;
    title?: string | undefined;
    city?: string | undefined;
    state_Id?: number | undefined;
    state?: CountryState;
    country_Id?: number;
    country?: NamedModel;
    start_Date?: Date;
    end_Date?: Date | undefined;
    web_Address?: string | undefined;
    is_Present?: boolean | undefined;
    has_Country_States?: boolean | undefined;
}

export class UserLinkedIn implements IUserLinkedIn {
    id?: number;
    user_Id?: number;
    user?: User;
    url?: string | undefined;

    constructor(data?: IUserLinkedIn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): UserLinkedIn {
        data = typeof data === 'object' ? data : {};
        let result = new UserLinkedIn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUserLinkedIn {
    id?: number;
    user_Id?: number;
    user?: User;
    url?: string | undefined;
}

export class UserProfessionalAssociation implements IUserProfessionalAssociation {
    id?: number;
    user_Id?: number;
    user?: User;
    association_Name?: string | undefined;
    start_Year?: number | undefined;
    end_Year?: number | undefined;
    is_Present?: boolean | undefined;

    constructor(data?: IUserProfessionalAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.association_Name = _data["association_Name"];
            this.start_Year = _data["start_Year"];
            this.end_Year = _data["end_Year"];
            this.is_Present = _data["is_Present"];
        }
    }

    static fromJS(data: any): UserProfessionalAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfessionalAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["association_Name"] = this.association_Name;
        data["start_Year"] = this.start_Year;
        data["end_Year"] = this.end_Year;
        data["is_Present"] = this.is_Present;
        return data; 
    }
}

export interface IUserProfessionalAssociation {
    id?: number;
    user_Id?: number;
    user?: User;
    association_Name?: string | undefined;
    start_Year?: number | undefined;
    end_Year?: number | undefined;
    is_Present?: boolean | undefined;
}

export class ExternalResponse implements IExternalResponse {
    response?: string | undefined;

    constructor(data?: IExternalResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.response = _data["response"];
        }
    }

    static fromJS(data: any): ExternalResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["response"] = this.response;
        return data; 
    }
}

export interface IExternalResponse {
    response?: string | undefined;
}

export class UserCrd implements IUserCrd {
    id?: number;
    user_Id?: number;
    user?: User;
    crd_Number?: string | undefined;

    constructor(data?: IUserCrd) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.crd_Number = _data["crd_Number"];
        }
    }

    static fromJS(data: any): UserCrd {
        data = typeof data === 'object' ? data : {};
        let result = new UserCrd();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["crd_Number"] = this.crd_Number;
        return data; 
    }
}

export interface IUserCrd {
    id?: number;
    user_Id?: number;
    user?: User;
    crd_Number?: string | undefined;
}

export class UserClientFocus implements IUserClientFocus {
    id?: number;
    user_Id?: number;
    user?: User;
    client_Focus_Id?: number;
    clientFocus?: NamedModel;

    constructor(data?: IUserClientFocus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.client_Focus_Id = _data["client_Focus_Id"];
            this.clientFocus = _data["clientFocus"] ? NamedModel.fromJS(_data["clientFocus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserClientFocus {
        data = typeof data === 'object' ? data : {};
        let result = new UserClientFocus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["client_Focus_Id"] = this.client_Focus_Id;
        data["clientFocus"] = this.clientFocus ? this.clientFocus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserClientFocus {
    id?: number;
    user_Id?: number;
    user?: User;
    client_Focus_Id?: number;
    clientFocus?: NamedModel;
}

export class UserContactFrequency implements IUserContactFrequency {
    id?: number;
    user?: User;
    frequency_Id?: number;
    frequency?: NamedModel;
    user_Id?: number;

    constructor(data?: IUserContactFrequency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.frequency_Id = _data["frequency_Id"];
            this.frequency = _data["frequency"] ? NamedModel.fromJS(_data["frequency"]) : <any>undefined;
            this.user_Id = _data["user_Id"];
        }
    }

    static fromJS(data: any): UserContactFrequency {
        data = typeof data === 'object' ? data : {};
        let result = new UserContactFrequency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["frequency_Id"] = this.frequency_Id;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["user_Id"] = this.user_Id;
        return data; 
    }
}

export interface IUserContactFrequency {
    id?: number;
    user?: User;
    frequency_Id?: number;
    frequency?: NamedModel;
    user_Id?: number;
}

export class UserContactTime implements IUserContactTime {
    id?: number;
    user_Id?: number;
    user?: User;
    contact_Time_Id?: number;
    contactTime?: NamedModel;

    constructor(data?: IUserContactTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.contact_Time_Id = _data["contact_Time_Id"];
            this.contactTime = _data["contactTime"] ? NamedModel.fromJS(_data["contactTime"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserContactTime {
        data = typeof data === 'object' ? data : {};
        let result = new UserContactTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["contact_Time_Id"] = this.contact_Time_Id;
        data["contactTime"] = this.contactTime ? this.contactTime.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserContactTime {
    id?: number;
    user_Id?: number;
    user?: User;
    contact_Time_Id?: number;
    contactTime?: NamedModel;
}

export class UserDesiredSolutionService implements IUserDesiredSolutionService {
    id?: number;
    user_Id?: number;
    user?: User;
    desired_Solution_Service_Id?: number;
    desiredSolutionService?: NamedModel;

    constructor(data?: IUserDesiredSolutionService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.desired_Solution_Service_Id = _data["desired_Solution_Service_Id"];
            this.desiredSolutionService = _data["desiredSolutionService"] ? NamedModel.fromJS(_data["desiredSolutionService"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDesiredSolutionService {
        data = typeof data === 'object' ? data : {};
        let result = new UserDesiredSolutionService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["desired_Solution_Service_Id"] = this.desired_Solution_Service_Id;
        data["desiredSolutionService"] = this.desiredSolutionService ? this.desiredSolutionService.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserDesiredSolutionService {
    id?: number;
    user_Id?: number;
    user?: User;
    desired_Solution_Service_Id?: number;
    desiredSolutionService?: NamedModel;
}

export class UserInvestmentImplementation implements IUserInvestmentImplementation {
    id?: number;
    user_Id?: number;
    user?: User;
    investment_Implementation_Id?: number;
    investmentImplementation?: NamedModel;

    constructor(data?: IUserInvestmentImplementation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.investment_Implementation_Id = _data["investment_Implementation_Id"];
            this.investmentImplementation = _data["investmentImplementation"] ? NamedModel.fromJS(_data["investmentImplementation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserInvestmentImplementation {
        data = typeof data === 'object' ? data : {};
        let result = new UserInvestmentImplementation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["investment_Implementation_Id"] = this.investment_Implementation_Id;
        data["investmentImplementation"] = this.investmentImplementation ? this.investmentImplementation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserInvestmentImplementation {
    id?: number;
    user_Id?: number;
    user?: User;
    investment_Implementation_Id?: number;
    investmentImplementation?: NamedModel;
}

export class UserPreferredEngagement implements IUserPreferredEngagement {
    id?: number;
    user_Id?: number;
    user?: User;
    preferred_Engagement_Id?: number;
    preferredEngagement?: NamedModel;

    constructor(data?: IUserPreferredEngagement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.preferred_Engagement_Id = _data["preferred_Engagement_Id"];
            this.preferredEngagement = _data["preferredEngagement"] ? NamedModel.fromJS(_data["preferredEngagement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserPreferredEngagement {
        data = typeof data === 'object' ? data : {};
        let result = new UserPreferredEngagement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["preferred_Engagement_Id"] = this.preferred_Engagement_Id;
        data["preferredEngagement"] = this.preferredEngagement ? this.preferredEngagement.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserPreferredEngagement {
    id?: number;
    user_Id?: number;
    user?: User;
    preferred_Engagement_Id?: number;
    preferredEngagement?: NamedModel;
}

export class UserAllocation implements IUserAllocation {
    id?: number;
    user_Id?: number;
    user?: User;
    allocation_Id?: number;
    allocation?: NamedModel;

    constructor(data?: IUserAllocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.allocation_Id = _data["allocation_Id"];
            this.allocation = _data["allocation"] ? NamedModel.fromJS(_data["allocation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserAllocation {
        data = typeof data === 'object' ? data : {};
        let result = new UserAllocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["allocation_Id"] = this.allocation_Id;
        data["allocation"] = this.allocation ? this.allocation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserAllocation {
    id?: number;
    user_Id?: number;
    user?: User;
    allocation_Id?: number;
    allocation?: NamedModel;
}

export class UserAlternative implements IUserAlternative {
    id?: number;
    user_Id?: number;
    user?: User;
    alternative_Id?: number;
    alternative?: NamedModel;

    constructor(data?: IUserAlternative) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.alternative_Id = _data["alternative_Id"];
            this.alternative = _data["alternative"] ? NamedModel.fromJS(_data["alternative"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserAlternative {
        data = typeof data === 'object' ? data : {};
        let result = new UserAlternative();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["alternative_Id"] = this.alternative_Id;
        data["alternative"] = this.alternative ? this.alternative.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserAlternative {
    id?: number;
    user_Id?: number;
    user?: User;
    alternative_Id?: number;
    alternative?: NamedModel;
}

export class UserCommodity implements IUserCommodity {
    id?: number;
    user_Id?: number;
    user?: User;
    commodity_Id?: number;
    commodity?: NamedModel;

    constructor(data?: IUserCommodity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.commodity_Id = _data["commodity_Id"];
            this.commodity = _data["commodity"] ? NamedModel.fromJS(_data["commodity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserCommodity {
        data = typeof data === 'object' ? data : {};
        let result = new UserCommodity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["commodity_Id"] = this.commodity_Id;
        data["commodity"] = this.commodity ? this.commodity.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserCommodity {
    id?: number;
    user_Id?: number;
    user?: User;
    commodity_Id?: number;
    commodity?: NamedModel;
}

export class UserEquity implements IUserEquity {
    id?: number;
    user_Id?: number;
    user?: User;
    equity_Id?: number;
    equity?: NamedModel;

    constructor(data?: IUserEquity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.equity_Id = _data["equity_Id"];
            this.equity = _data["equity"] ? NamedModel.fromJS(_data["equity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserEquity {
        data = typeof data === 'object' ? data : {};
        let result = new UserEquity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["equity_Id"] = this.equity_Id;
        data["equity"] = this.equity ? this.equity.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserEquity {
    id?: number;
    user_Id?: number;
    user?: User;
    equity_Id?: number;
    equity?: NamedModel;
}

export class UserInternationalEquity implements IUserInternationalEquity {
    id?: number;
    user_Id?: number;
    user?: User;
    intl_Equity_Id?: number;
    international_Equity?: NamedModel;

    constructor(data?: IUserInternationalEquity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.intl_Equity_Id = _data["intl_Equity_Id"];
            this.international_Equity = _data["international_Equity"] ? NamedModel.fromJS(_data["international_Equity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserInternationalEquity {
        data = typeof data === 'object' ? data : {};
        let result = new UserInternationalEquity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["intl_Equity_Id"] = this.intl_Equity_Id;
        data["international_Equity"] = this.international_Equity ? this.international_Equity.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserInternationalEquity {
    id?: number;
    user_Id?: number;
    user?: User;
    intl_Equity_Id?: number;
    international_Equity?: NamedModel;
}

export class UserMoneyMarket implements IUserMoneyMarket {
    id?: number;
    user_Id?: number;
    user?: User;
    money_Market_Id?: number;
    moneyMarket?: NamedModel;

    constructor(data?: IUserMoneyMarket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.money_Market_Id = _data["money_Market_Id"];
            this.moneyMarket = _data["moneyMarket"] ? NamedModel.fromJS(_data["moneyMarket"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserMoneyMarket {
        data = typeof data === 'object' ? data : {};
        let result = new UserMoneyMarket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["money_Market_Id"] = this.money_Market_Id;
        data["moneyMarket"] = this.moneyMarket ? this.moneyMarket.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserMoneyMarket {
    id?: number;
    user_Id?: number;
    user?: User;
    money_Market_Id?: number;
    moneyMarket?: NamedModel;
}

export class UserMunicipalBond implements IUserMunicipalBond {
    id?: number;
    user_Id?: number;
    user?: User;
    municipal_Bond_Id?: number;
    municipalBond?: NamedModel;

    constructor(data?: IUserMunicipalBond) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.municipal_Bond_Id = _data["municipal_Bond_Id"];
            this.municipalBond = _data["municipalBond"] ? NamedModel.fromJS(_data["municipalBond"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserMunicipalBond {
        data = typeof data === 'object' ? data : {};
        let result = new UserMunicipalBond();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["municipal_Bond_Id"] = this.municipal_Bond_Id;
        data["municipalBond"] = this.municipalBond ? this.municipalBond.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserMunicipalBond {
    id?: number;
    user_Id?: number;
    user?: User;
    municipal_Bond_Id?: number;
    municipalBond?: NamedModel;
}

export class UserProduct implements IUserProduct {
    id?: number;
    user_Id?: number;
    user?: User;
    product_Id?: number;
    product?: NamedModel;

    constructor(data?: IUserProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.product_Id = _data["product_Id"];
            this.product = _data["product"] ? NamedModel.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserProduct {
        data = typeof data === 'object' ? data : {};
        let result = new UserProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["product_Id"] = this.product_Id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserProduct {
    id?: number;
    user_Id?: number;
    user?: User;
    product_Id?: number;
    product?: NamedModel;
}

export class UserSectorEquity implements IUserSectorEquity {
    id?: number;
    user_Id?: number;
    user?: User;
    sector_Equity_Id?: number;
    sectorEquity?: NamedModel;

    constructor(data?: IUserSectorEquity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.sector_Equity_Id = _data["sector_Equity_Id"];
            this.sectorEquity = _data["sectorEquity"] ? NamedModel.fromJS(_data["sectorEquity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserSectorEquity {
        data = typeof data === 'object' ? data : {};
        let result = new UserSectorEquity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["sector_Equity_Id"] = this.sector_Equity_Id;
        data["sectorEquity"] = this.sectorEquity ? this.sectorEquity.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserSectorEquity {
    id?: number;
    user_Id?: number;
    user?: User;
    sector_Equity_Id?: number;
    sectorEquity?: NamedModel;
}

export class UserTaxableBond implements IUserTaxableBond {
    id?: number;
    user_Id?: number;
    user?: User;
    taxable_Bond_Id?: number;
    taxableBond?: NamedModel;

    constructor(data?: IUserTaxableBond) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.taxable_Bond_Id = _data["taxable_Bond_Id"];
            this.taxableBond = _data["taxableBond"] ? NamedModel.fromJS(_data["taxableBond"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserTaxableBond {
        data = typeof data === 'object' ? data : {};
        let result = new UserTaxableBond();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["taxable_Bond_Id"] = this.taxable_Bond_Id;
        data["taxableBond"] = this.taxableBond ? this.taxableBond.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserTaxableBond {
    id?: number;
    user_Id?: number;
    user?: User;
    taxable_Bond_Id?: number;
    taxableBond?: NamedModel;
}

export class UserRegistration implements IUserRegistration {
    id?: number;
    user_Id?: number;
    user?: User;
    registration_Id?: number;
    registration?: NamedModel;

    constructor(data?: IUserRegistration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.registration_Id = _data["registration_Id"];
            this.registration = _data["registration"] ? NamedModel.fromJS(_data["registration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRegistration {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegistration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["registration_Id"] = this.registration_Id;
        data["registration"] = this.registration ? this.registration.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserRegistration {
    id?: number;
    user_Id?: number;
    user?: User;
    registration_Id?: number;
    registration?: NamedModel;
}

export class UserCertification implements IUserCertification {
    id?: number;
    user_Id?: number;
    user?: User;
    certificate_Id?: number;
    certification?: NamedModel;

    constructor(data?: IUserCertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.certificate_Id = _data["certificate_Id"];
            this.certification = _data["certification"] ? NamedModel.fromJS(_data["certification"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserCertification {
        data = typeof data === 'object' ? data : {};
        let result = new UserCertification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["certificate_Id"] = this.certificate_Id;
        data["certification"] = this.certification ? this.certification.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserCertification {
    id?: number;
    user_Id?: number;
    user?: User;
    certificate_Id?: number;
    certification?: NamedModel;
}

export class UserIndustryExperience implements IUserIndustryExperience {
    id?: number;
    user?: User;
    experience_Id?: number;
    registrationCertification?: NamedModel;
    user_Id?: number;

    constructor(data?: IUserIndustryExperience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.experience_Id = _data["experience_Id"];
            this.registrationCertification = _data["registrationCertification"] ? NamedModel.fromJS(_data["registrationCertification"]) : <any>undefined;
            this.user_Id = _data["user_Id"];
        }
    }

    static fromJS(data: any): UserIndustryExperience {
        data = typeof data === 'object' ? data : {};
        let result = new UserIndustryExperience();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["experience_Id"] = this.experience_Id;
        data["registrationCertification"] = this.registrationCertification ? this.registrationCertification.toJSON() : <any>undefined;
        data["user_Id"] = this.user_Id;
        return data; 
    }
}

export interface IUserIndustryExperience {
    id?: number;
    user?: User;
    experience_Id?: number;
    registrationCertification?: NamedModel;
    user_Id?: number;
}

export class UserTeamReviewer implements IUserTeamReviewer {
    id?: number;
    user_Id?: number;
    user?: User;
    reviewer?: string | undefined;

    constructor(data?: IUserTeamReviewer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user_Id = _data["user_Id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.reviewer = _data["reviewer"];
        }
    }

    static fromJS(data: any): UserTeamReviewer {
        data = typeof data === 'object' ? data : {};
        let result = new UserTeamReviewer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user_Id"] = this.user_Id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["reviewer"] = this.reviewer;
        return data; 
    }
}

export interface IUserTeamReviewer {
    id?: number;
    user_Id?: number;
    user?: User;
    reviewer?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}